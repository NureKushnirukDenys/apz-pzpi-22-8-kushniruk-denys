Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Практична робота №1
з дисципліни «Архітектура програмного забезечення»








Виконав:									Перевірив:
ст. гр. ПЗПІ-22-8								ст. викладач.
Кушнірук Денис 								Сокорчук І.П









Харків 2025

1 ІСТОРІЯ ЗМІН

Табл. 1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	06.04.2025	0.1	

2 ЗАВДАННЯ

У рамках практичної роботи №1 з дисципліни «Архітектура програмного забезпечення» було поставлено завдання дослідити та вивчити патерн проєктування Composite (Компонувальник). Це потребувало глибокого аналізу даного патерну з точки зору його структури, основних принципів та практичного застосування в реальних проєктах.
     Необхідно було ознайомитися з теоретичною базою патерну Composite, зрозуміти його місце в загальній класифікації патернів проєктування (структурний патерн).
     Важливою частиною завдання було також визначення ситуацій, у яких доцільно застосовувати патерн Composite, аналіз його переваг та потенційних недоліків.
     Загалом, завдання було спрямоване на комплексне вивчення патерну проєктування Composite, розвиток навичок аналізу та реалізації патернів проєктування, а також удосконалення вмінь представлення технічної інформації через презентацію та усну доповідь.

3 ОПИС ВИКОНАНОЇ РОБОТИ

У процесі виконання роботи було досліджено та проаналізовано патерн проєктування Composite у контексті React. Цей патерн належить до категорії структурних патернів проєктування і є одним із найбільш поширених у веб-розробці, особливо в розробці інтерфейсів користувача з використанням компонентів.

3.1 Сутність патерну "Composite":
Патерн Composite дозволяє організовувати об'єкти в ієрархічні структури, що дозволяє обробляти окремі об'єкти та складені з них групи однотипно. Основна мета цього патерну — забезпечити можливість обробляти інтерфейси з дерева компонентів, де кожен компонент може бути як окремим об'єктом, так і складеним з інших компонентів.

3.2 Структура патерну:

-  Component — абстрактний клас або інтерфейс, що визначає спільні методи для всіх компонентів.
-  Leaf — конкретний компонент, який не має дітей і реалізує базові методи.
-  Composite — складний компонент, що може містити в собі інші компоненти (як Leaf, так і інші Composite).

3.3 Принцип роботи патерну:

Патерн Composite дозволяє об'єктам, які реалізують інтерфейс Component, бути як простими, так і складеними. Компонент Composite може містити інші компоненти і делегувати їм виконання завдань, наприклад, рендеринг або обробку подій. Це дозволяє будувати дерева компонентів, де кожен вузол є як окремим елементом, так і контейнером для інших елементів.

3.4	 Застосовність:

Патерн Composite є корисним у випадках:
-	Коли необхідно обробляти дерева або вкладені структури даних.
-	Коли компоненти можуть бути одночасно складеними з інших компонентів, що дозволяє повторно використовувати код.
-	Коли потрібна можливість рекурсивної обробки елементів.

3.5	Переваги та недоліки:

Переваги:
-	Спрощує роботу з деревоподібними структурами.
-	Забезпечує можливість повторного використання компонентів.
-	Легко підтримується і розширюється.
Недоліки:
-	Може призвести до ускладнення логіки, якщо дерево компонентів занадто велике або глибоке.
-	Може виникати перевантаження компонентів зайвою відповідальністю.
-	Потрібно ретельно слідкувати за продуктивністю, оскільки глибокі дерева можуть викликати проблеми з ефективністю.

3.6	 Реальні приклади використання:

Патерн Composite широко використовується в таких веб-продуктах, як інтерфейси користувачів для веб-додатків. Наприклад, у React компоненти можуть бути як простими, так і складеними, і можна комбінувати компоненти в деревоподібні структури для побудови гнучких та масштабованих інтерфейсів.

3.7	 Реалізація патерну на TypeScript:

У цьому звіті була реалізована система компонентів на TypeScript, що демонструє застосування патерну Composite для рендерингу дерева компонентів. Цей приклад показав, як можна створювати складні інтерфейси з простих частин і використовувати патерн для підтримки складених структур UI.
Цей приклад продемонстрував основні переваги патерну Composite, зокрема гнучкість у побудові та розширенні компонентів, а також простоту підтримки вкладених структур у великих додатках.

4	ВИСНОВКИ

У результаті виконаної роботи було детально досліджено патерн проєктування Composite та його застосування в контексті веб-розробки з використанням React і TypeScript. Патерн Composite дозволяє ефективно організовувати компоненти в ієрархічні структури, що спрощує підтримку і розширюваність складних інтерфейсів користувача. Реалізація цього патерну продемонструвала його переваги, зокрема гнучкість і можливість повторного використання компонентів.
 
ДОДАТОК А

Відеозапис доповіді на YouTube: https://youtu.be/nvtZlFum1oM
0:00 - Вступ 
0:16 - Що таке патерн проєктування? 
0:55 - Категорії патернів 
1:54 - Визначення Composite 
2:37 - Принцип роботи 
3:17 - React = Компонентна можель 
4:18 - Переваги патерну Composite 
5:20 - Недоліки патерну Composite 
6:14 - Висновки 
6:52 - Використані джерела
 
ДОДАТОК Б

 
Рисунок Б. 1 – Титульний слайд

 
Рисунок Б. 2 – Що таке патерни проєктування

 
Рисунок Б. 3 – Категорії патернів


 
Рисунок Б. 4 – Визначення Composite

 
Рисунок Б. 5 – Принцип роботи

 
Рисунок Б. 6 – Компонентна модель

 
Рисунок Б. 7 – Переваги патерну Composite

 
Рисунок Б. 8 – Недоліки патерну Composite

 
Рисунок Б. 9 – Висновки

 
Рисунок Б. 9 – Список використаних джерел
 
ДОДАТОК В

1. // Компонентний інтерфейс
2. interface Component {
3.   operation(): void;
4. }
5. 
6. // Листок (Leaf) - конкретний компонент
7. class Leaf implements Component {
8.   constructor(private name: string) {}
9. 
10.   operation(): void {
11.     console.log(`Leaf: ${this.name}`);
12.   }
13. }
14. 
15. // Композит (Composite) - контейнер для компонентів
16. class Composite implements Component {
17.   private children: Component[] = [];
18. 
19.   add(child: Component): void {
20.     this.children.push(child);
21.   }
22. 
23.   operation(): void {
24.     console.log("Composite operation:");
25.     for (const child of this.children) {
26.       child.operation();
27.     }
28.   }
29. }
30. 
31. // Використання патерну Composite
32. const leaf1 = new Leaf("Leaf 1");
33. const leaf2 = new Leaf("Leaf 2");
34. 
35. const composite = new Composite();
36. composite.add(leaf1);
37. composite.add(leaf2);
38. 
39. composite.operation();  // Викликає операцію для всіх компонентів
40. 
41. import React from 'react';
42. 
43. // Батьківський компонент Container
44. const Container: React.FC = ({ children }) => {
45.   return (
46.     <div className="container">
47.       <h2>Container Component</h2>
48.       <div className="content">
49.         {children} {/* Відображення вкладених компонентів */}
50.       </div>
51.     </div>
52.   );
53. };
54. 
55. // Дочірні компоненти
56. const Header: React.FC = () => {
57.   return <h3>Header Component</h3>;
58. };
59. 
60. const Footer: React.FC = () => {
61.   return <footer>Footer Component</footer>;
62. };
63. 
64. // Основний компонент, що складається з Container
65. const App: React.FC = () => {
66.   return (
67.     <Container>
68.       <Header /> {/* Вкладений Header */}
69.       <p>This is some content inside the container.</p>
70.       <Footer /> {/* Вкладений Footer */}
71.     </Container>
72.   );
73. };
74. 
75. export default App;
